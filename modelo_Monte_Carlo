---------- Instalação e Importação das Bibliotecas
!pip install -q yfinance

import pandas as pd
import numpy as np
import plotly.express as px
import seaborn as sns
import yfinance as yf
import datetime
from prophet.forecaster import Prophet
from statsmodels.tsa.seasonal import seasonal_decompose
from sklearn.metrics import mean_absolute_error
from scipy import stats


---------- Construção do Dataset
dateparse = lambda dates: datetime.datetime.strptime(dates, '%Y-%m-%d')
from datetime import date, timedelta

dt_atual = date.today()
td = timedelta(1095)

df = yf.download("BOVA11.SA", start=(dt_atual-td))['Close']

df = df.reset_index()
df

df_bova = pd.DataFrame(df['Close'])
df_bova


---------- Excluindo Outliers
dados = df_bova
boxplot_bova = px.box(dados, y="Close")
boxplot_bova.show()

q1 = np.quantile(dados, .25, interpolation="midpoint")
q2 = np.quantile(dados, .5, interpolation="midpoint")
q3 = np.quantile(dados, .75, interpolation="midpoint")
IIQ = q3 - q1

### Limite inferior do boxplot
limite_inferior = q1 - 1.5 * IIQ
limite_inferior

### Limite superior do boxplot
limite_superior = q3 + 1.5 * IIQ
limite_superior

df_bova_lim_inf = df_bova[df_bova['Close']>limite_inferior]
df_bova_clean = df_bova_lim_inf[df_bova_lim_inf['Close']<limite_superior]
df_bova_clean

df_bova = df_bova_clean
df_bova

### Normalizando o Dataframe
df_normalizado = df_bova.copy()
for i in df_bova:
  df_normalizado[i] = df_bova[i] / df_bova[i][0]
df_normalizado

### Calculando a taxa de retorno
df_taxa_retorno = np.log(1 + df_normalizado.pct_change())
df_taxa_retorno


---------- Movimento Browniano com Drift
### Drift
drift = df_taxa_retorno.mean() - (0.5 * df_taxa_retorno.var())
drift


---------- Retorno Diário
### Definição da quantidade de dias futuro e total de simulções
dias = 90
simulacao = 10

### Desvio Padrão
desvio_padrao = df_taxa_retorno.std()
desvio_padrao

### Padronização
Z = stats.norm.ppf(np.random.rand(dias, simulacao))

### Definição do retorno diário
retorno_diario = np.exp(drift.values + desvio_padrao.values * Z)

retorno_diario.shape

### Definição da matriz de zeros
previsao = np.zeros_like(retorno_diario)

previsao[0] = df_bova.iloc[-1]
previsao

### Gerando valores da previsão
for dia in range(1, dias):
  previsao[dia] = previsao[dia - 1] * retorno_diario[dia]
  
previsao.shape
  
  
---------- Geração do Gráfico
### Matriz transposta
previsao.T

### Parâmetros do gráfico
figura = px.line(title = 'Simulação de Monte Carlo - Ações da BOVA')
for i in range(len(previsao.T)):
  figura.add_scatter(y = previsao.T[i], name = i)
figura.show()
 

---------- Avaliação da Previsão
from datetime import date, timedelta

dt_atual_02 = date.today()
td_02 = timedelta(130)

df2 = yf.download("BOVA11.SA", start=(dt_atual_02-td_02))['Close']

df2 = df2.reset_index()
df2

df_bova_02 = pd.DataFrame(df2['Close'])
df_bova_02

boxplot_avaliacao = px.box(df_bova_02, y="Close")
boxplot_avaliacao.show()

len(df_bova_02)

simulacao_01 = previsao.T[0][0:len(df_bova_02)]
simulacao_01

len(simulacao_01)

df_bova_02['Close']

from sklearn.metrics import mean_absolute_error
mean_absolute_error(df_bova_02['Close'], simulacao_01)

erro = []
for i in range(len(previsao.T)):
  simulacao_01 = previsao.T[i][0:len(df_bova_02)]
  erro.append(mean_absolute_error(df_bova_02['Close'], simulacao_01))

erro

erro.index(max(erro)), erro.index(min(erro))

figura = px.line(title = 'Previsões do preço das ações da BOVA - simulação')
figura.add_scatter(y = df_bova_02['Close'], name = 'Valor real')
figura.add_scatter(y = previsao.T[erro.index(max(erro))], name = 'Pior simulação')
figura.add_scatter(y = previsao.T[erro.index(min(erro))], name = 'Melhor simulação')
